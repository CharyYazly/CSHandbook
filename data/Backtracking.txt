## Introduction

Backtracking is a search that find all possible solutions by enumerating on a partial solution. Backtracking can be done using DFS or BFS. In some cases DFS can be better than BFS and in some cases BFS can be better than DFS.

Since backtracking requires enumerating through all solutions, it is usually slow with runtimes usually O(n!) or O(2^n). 

## General Solution

[[[[
void backtrack(i,candidate){
   if(reject(candidate))return;
   if(i>=n){
      output(candidate);
      return;
   }
   for(j=0;j<m;j++){
      backtrack(i,candidate);
   }
}
]]]]

## List all sets

Given a set of numbers S of length N, output all subsets of S.

For example S=[1,2,3,4]. The subsets encodings of [1,2,3,4]:

{}
{1}, {2}, {3}, {4}
{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4}
{1,2,3}, {1,2,4},{1,3,4},{2,3,4}
{1,2,3,4}
We want to be able to enumerate all the subsets of S so we need to find a way to encode a subset of an array. We can use a binary number of length N to encode a subset of an array of length N. For example a 1 represents we use a number in the set and a 0 means we don't use a number in the set.

So above:

{} = 0000
{1} = 1000
{2} = 0100
{3} = 0010
{4} = 0001
{1,2} = 1100
{1,3} = 1010
{1,4} = 1001
{2,3} = 0110
{2,4} = 0101
{3,4} = 0011
{1,2,3} = 1110
{1,2,4} = 1101
{1,3,4} = 1011
{2,3,4} = 0111
{1,2,3,4} = 1111
At each position we either take or don't take the number in the set and we can do this for each number. We can enumerate through all these encoding by first starting with 0 or 1 and appending more 0's or 1's.

Here is the way we would do this problem with recursion:
[[[[
Start with []
Add 1 and 0 to the right of each binary number in the array
Repeat until N
[0,1]
[00,01,10,11]
[000,001,010,011,100,101,110,111]
[0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111]
Let S be an array of N integers
Let subsets(arr,n) be subsets of S from 1 to n
 
Base case
S(set,0) = set
 
Recurrence
S(set,n) = subsets([sub+0 for sub in set] + [sub+1 for sub in set],n)
 
Example
 
subsets([],4)
subsets([0,1],3)
subsets([00,01,10,11],2)
subsets([000,001,010,011,100,101,110,111],1)
subsets([0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111],0)
=
[0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111]
 ]]]]
Here is the way we would do this problem with backtracking, however it takes a lot of memory to store **ALL** the solutions. Instead of building all the solutions, we can build each solution one by one.
[[[[
Base case
subset(0, binary): print binary
 
Recurrence
subset(n-1,binary+'0')
subset(n-1,binary+'1')
 
Example
subset(4,'')
 
subset(3,'0')
subset(3,'1')
 
subset(2,'00')
subset(2,'01')
subset(2,'10')
subset(2,'11')
 
subset(1,'000')
subset(1,'001')
subset(1,'010')
subset(1,'011')
subset(1,'100')
subset(1,'101')
subset(1,'110')
subset(1,'111')
 
subset(0,'0000')
subset(0,'0001')
subset(0,'0010')
subset(0,'0011')
subset(0,'0100')
subset(0,'0101')
subset(0,'0110')
subset(0,'0111')
subset(0,'1000')
subset(0,'1001')
subset(0,'1010')
subset(0,'1011')
subset(0,'1100')
subset(0,'1101')
subset(0,'1110')
subset(0,'1111')
 
void subsets(int arr[],bool use[],int i){
    if(i>=arr.length){
         for(int j=0;j<n;j++){
              System.out.print("%d ",arr[i]);
         }
         System.out.println();
         return;
     }
     use[i] = false;
     subsets(arr,use,i+1);
     use[i] = true;
     subsets(arr,use,i+1);
}
subsets([1,2,3,4],[0,0,0],0);
 
subsets([1,2,3,4],[0,0,0],0);
 
subsets([1,2,3,4],[1,0,0],0);
]]]]


## [[N Queen Problem]]

Find the number of ways to place N queens on a NxN board without any of them attacking each other. Queens attack each other by being along the same row, column or diagonal.

We can place a queen in each row and make sure that each column / diagonals is unfilled.

Let N be a NxN board where we want to place N queens 
Let queen(n,columns,d1,d2) be a placing of N queens across a board
 
Base case
queen(0,cols,d1,d2): print solution
 
Recurrence 
queen(n,cols,d1,d2) = queens(n-1,cols
 
Examples
 
 
 

## Exercises

1. Given a sequence of numbers, output all increasing subsequences