## Introduction

**Preqrequistes**: [[Recursion]]

Merge sort works by breaking down the sorting into smaller pieces. If we want to sort N elements, we can sort the first half of the elements, sort the second half and then merge the results together. To sort the first half, we can do the exact same thing of sorting the first quarter and the second quarter and merging the results.

## Implementation

Merge sort work be breaking down the problem into smaller and smaller parts and then combing those parts to solve the big problem. 

We can keep splitting the list into half until there each piece has 1 element or no elements. We can then combine the results of each piece repeatedly until the entire list is sorted.

Example:

{{mergesort.png}}

### Formalization

[[[[{lang-html}
Let merge(arr1,arr2) that combines two sorted arrays into one sorted array.

Example:
merge([1,5,7,9], [2,4,8])
= [1, 2, 4, 5, 7, 8, 9]

Let sort(arr) sort an array
Let middle be (0 + arr.length) / 2

sort([x]) = [x]
sort([x,y]) = [x,y] if x<y 
sort([x,y]) = [y,x] otherwise
sort(arr) = merge(sort(arr[0..middle]), sort(arr[middle..arr.length])

Example:
sort([3, 7, 1, 9, 8, 4, 5])
= merge(sort([3, 7, 1]), sort([9, 8, 4, 5]))
= merge(merge(sort([3, 7]), sort([1]), merge(sort([9, 8]), sort([4, 5])))
= merge(merge([3, 7], [1]), merge([8, 9], [4, 5])
= merge([1, 3, 7], [4, 5, 8, 9])
= [1, 3, 4, 5, 7, 8, 9]
]]]]

### Code

For our Java implementation, instead of returning a new array every time we merge two arrays, we can create a temporary array to store the merged results and then move it back.

[[[[
public void merge(int arr[], int start1, int end1, int start2, int end2) {
  int arr2[] = new int[end2 - start1 + 1];
  int begin = start1;
  int n = 0;

  // Pick smallest element one by one.
  while (start1 <= end1 && start2 <= end2) {
    // Take from first part.
    if (arr[start1] <= arr[start2]) {
      arr2[n] = arr[start1];
      start1++;
    }
    // Take from second part.
    else {
      arr2[n] = arr[start2];
      start2++;
    }
    n++;
  }
  // If first segment still has elements.
  while (start1 <= end1) {
    arr2[n] = arr[start1];
    n++;
    start1++;
  }
  // If second segment still has elements.
  while (start2 <= end2) {
    arr2[n] = arr[start2];
    start2++;
    n++;
  }
  // Copy merged array back.
  for (int i = 0; i < n; i++) {
    arr[begin + i] = arr2[i];
  }
}
// Merge sorts array from [start..end]
public void mergeSort(int arr[], int start, int end) {
  // Base case if 1 or 0 elements.
  if (end - start <= 0) {
    return;
  }
  int mid = (start + end) / 2;
  // Sort left side.
  mergeSort(arr, start, mid);
  // Sort right side.
  mergeSort(arr, mid + 1, end);
  // Merge both sides.
  merge(arr, start, mid, mid + 1, end);
}

// Example usage:
int arr[] = {5,7,2,6,8,5};
mergeSort(arr,0,arr.length-1);
]]]]


## Exercises

1. Write merge sort that uses no extra memory (no additional array).