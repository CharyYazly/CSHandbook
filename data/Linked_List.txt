## Introduction

*Prerequisites*: [[Queue]]

[[Source on Github||https://github.com/ayoungprogrammer/Algorithms/blob/master/src/LinkedList.java]]

Imagine you had some train cars that were linked together where each was labelled on the inside with a different letter. If you had to find a specific letter you would have to start at the first train car and look inside to check the letter and then walk into the next train car to check the letter and so forth until you found the train car you wanted. If you wanted to insert a train car somewhere all you would have to do it unlink the position where you wanted to insert it and then relink the new train car with the other cars. If you wanted to remove a train car all you would have to do is unlink that car from the other cars and then create a new link to the cars that were adjacent to it. This sort of structure is called a linked list.

A **pointer** is something that holds the memory location of another object.

{{linkedlist.png}}

A **linked list** is similar to an array but it is different such that it is not stored in one block of data. Each element can be stored in a random place in memory but each element contains a pointer to the next element thus forming a chain of pointers. Think of a pointer as a link that links two train cars. Since the elements aren't in a block, accessing an element must be done by traversing the entire linked list by following each pointer to the next. However, this also allows insertion to be done more quickly by simply changing the point of the previous element and setting to the pointer of the current element to the next element. Deletion is also done by taking the previous element and changing its pointer to two elements ahead. In a linked list the links only go forward and you cannot move backward. 

A **doubly linked list** is a linked list that has pointers going backwards as well as forwards.

{{doublelinkedlist.png}}

| Operation | Get | Push | Delete  | Insert
|-----------|---------|------------|---------
| Time Complexity | O(n) | O(1) | O(1) | O(1)

## Implementation

In Java, there already exists a LinkedList class but we will implement our own.

### Link Class

The Link class for each "link" in the Linked List. In each Link we only need the value and location of the previous and next node. 

[[[[
class Link{
	int value;
	Link next;
	public Link(int value){
		this.value = value;
		this.next = null;
	}
}
]]]]

### Class

Create the linked list by initializing the starting node as null and setting the size to empty.
[[[[
class LinkedList{
	Link head;
	Link end;
	int size;
	public LinkedList(){
		start = end = null;
		size = 0;
	}
}
]]]]
 
### Push

Create a new node with the value given and add it to the end. We have to set the current head previous node to the new node and the new next next to the last node.

{{linkedlistpush.png}}

{{linkedlistpush2.png}}

{{linkedlistpush3.png}}

[[[[
/*
 * Adds new node to head of linked list
 */
public void push(int value){
	Link newLink = new Link(value);
	if(size==0){
		head = end = newLink;
	}else{
		end.next = newLink;
		end = newLink;
	}
	size++;
}
]]]]

### Pop

Pops off the node at the head.

{{linkedlistpop.png}}

{{linkedlistpop2.png}}

[[[[
/*
 * Adds new node to head of linked list
 */
public int pop(){
	if(head==null){
		throw new NoSuchElementException();
	}
	int ret = head.value;
	head = head.next;
	size--;
	if(size==0){
		end = null;
	}
	return ret;
}
]]]]

### Get 

Get retrieves the value at the specified index. We have to loop through the entire list to get the index we want because the nodes are not in the same block of memory.

{{linkedlistget.png}}

{{linkedlistget2.png}}

{{linkedlistget3.png}}

[[[[
/*
* Gets the value at index
*/
public int get(int index){
	int i = 0;
	Link curNode = head;
	while(curNode!=null){
		if(index==i){
			return curNode.value;
		}
		curNode = curNode.next;
		i++;
	}
	throw new NoSuchElementException();
}
]]]]

### Delete

To delete the current node we set the previous node next link to the link after.

{{linkedlistrem.png}}

{{linkedlistrem2.png}}

[[[[
/*
 * Deletes node after specified
 */
public void deleteNext(Link node){
	if(node.next==end){
		end = node;
	}
	node.next = node.next.next;
	size--;
}
]]]]

## Exercises

1. Implement a doubly linked list.
2. A game is player by always eliminating the kth player from the last elimination and played until one player is left. Given N players each assigned to a number, find the number of the last player.
    
    For example, you have 5 players (1,2,3,4,5) and the 3rd player is eliminated. 
    * 1, 2, 3, 4, 5 
    * 1, 2, 4, 5 (1, 2, 3 is eliminated)
    * 2, 4, 5 (4, 5, 1 is eliminated)
    * 2, 4 (2, 4, 5 is eliminated)
    * 2 (2, 4, 2 is eliminated)
    * Player 2 is the last one standing.