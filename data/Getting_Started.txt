## Introduction

The Computer Science handbook is a handbook designed to explain algorithms and data structures in way that anyone can understand. A lot of websites (eg Wikipedia) contain lengthy and wordy explanations that are full of technical jargon. We have tried our hardest to simplify all language to make it easy to read without any math or computer science background. We hope to share our knowledge with you and we ask only one thing from you. You must learn something before you leave!

## [[Format]]

Each article with have multiple sections to help you understand the content.

### Introduction

The introduction section gives a brief overview of what the article is about. It will usually come with a prerequisite section which will contain topics that will be recommended to have been read before the article.

### Implementation

The implementation section will be an implementation of the article in Java. It is recommended that you try to implement things yourself first before looking at the implementation. If you truly understand the concept, then you will never have to memorize a single line of code. The code will come from your understanding of how it works. 

### Applications

The applications section will be about real world applications of the concept that show why the concept is important.

### Exercises

The exercises section contains practice problems to test if you truly understand the concept. Many of these questions actually come from real interview questions. 


## [[Data Types]]

We use closets or drawers to store our clothes and garages to store our cars. Similarly, we store different types of data in different kinds of data types. Most programming languages will support these data types and picking the right data type is important. 

To define a variable of a data type we use the follow syntax:

**datatype** **variable_name** = **init_val**;

* **datatype** is the type of variable
* **variable_name** is the name of the variable used
* **init_val** is the initial value of the variable

Example:
[[[[
int x = 3;
double y = -4.5;
]]]]

### [[Boolean]]

A boolean is stored in a bit that is either true or false. Booleans are usually used as flags to store if something is one one state or the other.

Data type| Number of bits | Range
-|-|-|-
bool| 2 bits | true or false

### [[Integer]]

An integer is any number that does not contain decimals. It is stored as binary number in memory. For example: 0, -5, 6 are integers.

Data type| Number of bits | Range
-|-|-|-
byte|8 bits| -128 to 127
short|16 bits | -32,768 to 32,767
int| 32 bits | −2,147,483,648 to 2,147,483,647
long| 64 bits | −9,223,372,036,854,775,808 to 9,223,372,036,854,755,807

### [[Character]]

A character is any letter or symbol. For example: 'a','B','8','!'.

Characters are usually stored as a number and then displayed as a character by the computer. When the computer converts a number to a character, it is called an encoding. For simple characters we store the character in 8 bits (0-255) and we can use it to represent English. This encoding is called ASCII. For example: '0' is 48 and 'B' is 66. There are other encodings like Unicode which uses more bits to convert to more languages such as Chinese or Russian. For the most part, we will just use ASCII.

Data type| Number of bits | Range
-|-|-|-
char| 8 bits | 256 bits

### [[Float]]

A float is a decimal stored as binary in memory. We use scientific notation to represent the decimal. Scientific notation is a decimal number < 10 times some exponent of 10. For example: 8.23 * 10^^4^^ is in scientific notation. Decimals can be stored in 32 bits or 64 bits. 

In a 32bit float, we have 1 bit for the sign (positive or negative), 23 bits for the significant figures (7 digits) and 8 bits for the exponent. 

Int a 64bit double we have 1 bit for the sign (positive or negative), 52 bits for the significant figures (16 digits) and 11 bits for the exponent. 

Data type| Number of bits | Range
-|-|-|-|-
float| 32 bits | 3.4e−038 to 3.4e+038
double| 64 bits| 1.7e−308 to 1.7e+308


## [[Operations]]

Java includes many built in operations for basic operations.

Operation|Description|Example
-|-|-|-|-
x + y|Addition|1 + 2 = 3
x - y|Subtraction|3 - 1 = 2
x * y|Multiplication|3 * 2 = 6
x / y|Integer division|5 / 2 = 2, 6 / 3 = 2
x % y|Modulus (or remainder)|5 % 3 = 2, 6 % 2 = 0
x++|Increment by 1|5++ = 6
x--|Decrement by 1|5-- = 4

Boolean operators are operations between two booleans (true or false). Boolean operators: 

Operation|Description|Example
-|-|-|-|-
\|\||Or (One have to be true)|True \|\| False = True, True \|\| True = True, False \|\| False = False
x&&y|And (Both have to be true| True && True = True, True && False = False, False && False = False
!x|Not|!False = true, !true = false
x == y|Equality| 1 == 1 = true, 1 == 3 = false
x != y|Inequality| 1 == 1 = false, 1 != 3 = true
x < y|Less than| 2 < 3 = true, 2 < 2 = false, 2 < 1 = false
x <= y|Less than or equal to| 2 <= 3 = true, 2 <= 2 = true, 2 <= 1 = false
x > y|Greater than|3 > 2 = true,3 > 3 = false, 3 > 4 = false
x >= y|Greater than or equal to|3 >= 2 = true,3 >= 3 = true, 3 >= 4 = false
exp ? x : y| Ternary (if exp is true use x otherwise use y) | true ? 3 : 4 = 3, (1 > 2) ? 3 : 4 = 4

Assignment assigns a value to a variable.

[[[[
int x = 3;
]]]]

Operation|Description|Example
-|-|-|-
x = y | Set x to y | x = 4 (x = 4)
x += y | Addition | x += 4 (x = 7)
x -= y | Subtraction | x -= 3 (x = 0)
x *= y | Multiplication | x *= 3 (x = 9)
x /= y | Division | x /= 2 (x = 1)
x %= y | Modulus | x %= 2 (x = 1)


## Conditional Statements

Let's say we wanted 

## [[Loops]]

Let's say we wanted to calculate the 4th power of two without using the math power function. We can do this easily with code.

[[[[
int x = 2*2*2*2;
]]]]
How about 10?
[[[[
int x = 2*2*2*2*2*2*2*2*2*2;
]]]]
How about 100?
We could copy and paste this more times but this get very tedious. Most programming languages have something called a loop which does the same action a number amount of times. 

A for loop structure is as follows:
[[[[
for( first exp; test exp; next exp){
    loop exp;
}
]]]]
The loop first executes the 

[[[[
int i = 0;
int x = 2;
for(i=1;i<100;i++){
   x = x * 2;
}
]]]]



## Runtime and Memory

Why is it that computers are a lot better at humans at one thing but humans are better than other things than computers? It's because computers are super fast at making calculation than computers but humans have much more "memory" than computers currently do. Computers can add two numbers together much more quickly than any human can. However, the human brain has about 100 billion neurons with 100 trillion connections between neurons. The neurons and connections allow us to store lots and lots of information in our brains and allows us to easily recognize patterns much better than computers. For example it is very easy for us to identify different objects around us (eg we can differentiate between an apple and an orange), but it is difficult for a computer to do this. 

|Brain|Computer
-|-|-
Memory|2.5 petabytes (3 million hours of tv shows)|16GB RAM
Processing|


There are many different methods of implementing different things but most of the time we care most about implementations that are the fastest and use the least amount of memory. Let's go through some basic benchmarks about computers that you should know. Adding two numbers takes a nanosecond (1 billionth of a second) for an average computer to process. For practical purposes, we'll assume that the average computer program can hold up to 1GB or RAM or about 250 million integers. 

When we compare how efficient algorithms or data structures are to another we use something called Big O notation to describe it. Usually every algorithm and data structure will depend on some inputs and the time it takes to compute something or the storage size needed will depend on that input. The Big O notation takes the largest factor of an input to compare computation times / memory usage. When we take the largest factor, we ignore smaller factors and constants because they do not matter at very large values. 

For example we want to store an array of N integers. We will need an array of size of N. We say that it takes O(N) memory. If we wanted to go through this array of N integers and find the greatest element, we keep a current max value and go through the array and if we saw a value greater than the max value we would set the new max value to that. 

Example code:

[[[[
int maxVal = array[0];
for(int i=1;i<array.length;i++){
   if(maxVal < array[i]){
       maxVal = array[i];
   }
}
]]]]

In addition to the array we store a new variable called maxVal. But this is only 1 number so it uses O(1) more memory. When we 

Here is a list of common Big O notation based on complexity.

* O(1)
* O(log N)
* O(N)
* O(N log N)
* O(N^^2^^)
* O(2^^N^^)
* O(N!)