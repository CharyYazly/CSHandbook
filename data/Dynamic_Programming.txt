## Introduction

Dynamic programming uses memoization by solving subproblems to solve the more complex problem. Dynamic programming uses recursion but instead of working backwards, it builds up the answer and reduces the number of duplicate computations. 

Like [[recursion|Recursion]], dynamic programming requires two things:

* A base case and
* A subproblem that can be reduced into smaller subproblems 

### Prerequisites

* [[Advanced Recursion]]

## Fibonacci Sequence

The Fibonacci sequence is determined by f(n) = f(n-1)+f(n-2) where f(0) = 1 and f(1) = 1. 

If we calculate f(5) we have:
[[[[
f(5) 
= f(4) + f(3) 
= f(3) + f(2) + f(2) + f(1) 
= f(2) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1) 
= f(1) + f(0) + f(1) + f(1) + f(0) + f(1) + f(0) + f(1) 
= 1 + 1 + 1 + 1 + 1 + 1 + 1
= 8
]]]]

However we are computing multiple values more than once. When we compute f(5) we need to compute f(4) and f(3) but f(3) is already computed when we compute f(4) and thus we have to recompute it again. We can avoid this redundancy by "building up". We can calculate f(2), then f(3) then f(4) and finally f(5) and we won't have duplicate calculations. 
[[[[
f(0) = 1
f(1) = 1
f(2) = f(1) + f(0) = 2
f(3) = f(2) + f(1) = 3
f(4) = f(3) + f(2) = 5
f(5) = f(4) + f(3) = 8
]]]]

### Formalization
Recursion
[[[[{lang-html}
Fibonacci sequence

Let f(n) be the nth Fibonacci number

Base case:
fib(0) = 1, fib(1) = 1

Subproblem:
fib(n) = fib(n-1) + fib(n-2)
]]]]

Dynamic Programming
[[[[
Let fib[n] be the nth Fibonacci number

Base case
fib[0] = 1
fib[1] = 1

for x from 1 to N
    fib[x] = fib[x-1] + fib[x-2]

Example:
N = 10
fib[0] = 1
fib[1] = 1
fib[2] = 2
fib[3] = 3
fib[4] = 5
fib[5] = 8
fib[6] = 13
fib[7] = 21
fib[8] = 34
fib[9] = 55
fib[10] = 89
]]]]

### Code

Recursion
[[[[
public int fib(int n){
    if(n==0 || n==1) return 1;
    return fib(n-1) + fib(n-2);
}
]]]]

Dynamic Programming
[[[[
public int fib(int n){
    int fibArr[] = new int[n];
    fibArr[0] = 1
    fibArr[1] = 1
    for(int x=2; x<n; x++){
         fibArr[x] = fibArr[x-1] + fibArr[x-2];
    }
    return fibArr[n];
}
]]]]

## [[Coin Problem]]

Let's say that you wanted to make change for $51 using the smallest amount of bills ($1, $2, $5, $10, $20). We can use a greedy approach by always taking the highest bill that can be subtracted to find the smallest amount of change. 51 - 20 = 31 - 20 = 11 - 10 = 1. So the smallest amount of change would be comprised of 2 x $20 + 1 x $10 + 1 for a total of 5 bills. This solution seems very easy to implement, but what if the bills were not so nice?

Imagine that an alien currency was in denominations of $3, $5, $7 and $11. What would be the smallest amount of bills to make change for $13? Note that a greedy approach does not work for this alien currency. For example: 13 - 11 = 2. It is impossible to make change using the greedy approach. Note that we can make change with 2 x $5 + 1 x $3 = $13.

Let's define the problem more formally: Given a list of bills each with a positive denominations, find the lowest amount of bills required to make C dollars or return impossible if it cannot be done.

The base case for 0 dollars is very simple. There are 0 bills to make 0 dollars.

Lets try to simply this problem. Assume we only have one bill worth d dollars. The minimum bills to make C dollars is the minimum number of bills to make (C - d) bills and add 1 for the bill d that we add to it. For example, we want to make 10 dollars and we only have 2 dollar bills. The minimum bills required to make 10 dollars is the minimum number of bills required to make 8 dollars plus one more 2 dollar bill. To find the minimum number of bills required to make 8 dollars, we can find the minimum number of bills to make 6 dollars plus one more 2 dollar bill. As you can see it is the same as before and it is a recursive function!

Recursion
[[[[
Let d be the denomination
Let bills(C) be the minimum number of bills to make C dollars.

Base Case:
bills(0) = 0
bills(C) = impossible if C < 0

Subproblem:
bills(C) = bills(C-d) + 1 if bills(C-d) is possible
               impossible if bills(C-d) is impossible

Example:
C = 10
d = 2

bills(10) 
= bills(8) + 1
= bills(6) + 1 + 1
= bills(4) + 1 + 1 + 1
= bills(2) + 1 + 1 + 1 + 1
= bills(0) + 1 + 1 + 1 + 1 + 1
= 5
]]]]

Dynamic Programming Implementation
[[[[
bills[0] = 0
for c from 1 to C
     if c-d >= 0 and bills[c-d] is not impossible
         bills[c] = bills[c-d] + 1
     else
         bills[c] = impossible

Example:
C = 10
d = 2

bills[0] = 0
bills[1] = impossible
bills[2] = 1
bills[3] = impossible
bills[4] = 2
bills[5] = impossible
bills[6] = 3
bills[7] = impossible
bills[8] = 4
bills[9] = impossible
bills[10] = 5
]]]]

Now let's consider the problem with multiple bills of denominations d1,d2 .... dn and we want to make C dollars. The minimum number of bills to make C dollars is the minimum of bills to make (C-d1) bills plus 1 more d1 bill, (C-d2) plus one more d2 bill ... (C-dn) bills plus 1 more dn bill. For example: 

[[[[
Let denom be a list of denominations
Let bills(C) be the minimum number of bills from denominations to make C dollars

Base Cases:
bills(0) = 0
bills(C) = impossible if C < 0

Subproblem
bill(C) = {  minimum of bills(C - d)+1 for d in denom if bills(C-d) is possible
             {  impossible if bills(C - d) is impossible for all d in denom

Example:
denom = [3,4,5]

bill(7)
= min(bill(4)+1,bill(3)+1,bill(2)+1))
= min(min(bill(1)+1,
           bill(0)+1,
           bill(-1)+1)+1, 
       min(bill(0)+1,
           bill(-1)+1,
           bill(-2)+1) +1, 
       min(bill(-1)+1),
           bill(-2)+1,
           bill(-3)+1)+1)
= min( min(impossible, 1, impossible) +1,
           min(1,impossible,impossible) +1,
           min(impossible,impossible,impossible)+1)
= min(2,2,impossible)
= 2

]]]]

However note, that we are recomputing multiple things. For example we are recomputing bill(0) multiple times and bill(-1) multiple times. If instead we worked the solution up instead of down, we can find bill(C) more efficiently. We can do this by computing bill(c) as c goes from 0 to C. Eg. we compute bill(0) then bill(1) then bill(2) .... until bill(C).

Putting it all together:

[[[[{lang-html}
Let bills[C] be the smallest amount of bills to make the amount C, or impossible if it is not possible
Let denom be an array of denominations

Base case:
bills[0] = 0

Subproblem:
for c from 1 to C
    bills[c] = impossible
    for d in denom
        if c-d >= 0 and bills[c-d] is not impossible:
            bills[c] = min(bills[c], bills[c-d]+1)

Example:
denom = [3,4,5]
C = 7
bills[0] = 0
bills[1] = impossible (bills[-2],bills[-3],bills[-4])
bills[2] = impossible 
bills[3] = 1 (bills[0]+1)
bills[4] = 1 (bills[0]+1)
bills[5] = 1 (bills[0]+1)
bills[6] = impossible
bills[7] = 2 (bills[3]+1 or bills[4]+1)
]]]]

## [[Knapsack Problem]]

Imagine you are a robber and you have found a large stash of valuables. Each valuable has a value and a weight. You can only hold 10kg in your bag and you want to find the highest valued haul you can get away with. 

* Necklace: $10, 1kg
* Stack of cash: $270, 3kg
* Jewelry: $665, 7kg
* Rare painting: $900, 9kg

Let's try a greedy approach: we will take the items with the highest value to weight ratio.

* Necklace: $10/kg
* Stack of cash: $90/kg
* Jewelry: $95/kg
* Rare painting: $100/kg

The greedy approach will choose the rare painting and the necklace for a total of $910. However if we take the jewelry and the stack of cash we will get $935 and still fit it into the bag. How can we solve this problem? The answer is dynamic programming. 

Let's first write a more formal definition of the problem:

Given n objects, each associated with a positive weight and value, and a maximum total weight W that we can hold, what is the maximum value we can hold. In the zero/one knapsack problem, there is only one of each object so we either take it or leave it.

Let's write a more specific version of the problem: we want to find the maximum value that a bag with maximum weight W can hold of N objects with positive weight and value which we can either take or not take.

The base case for this is trivial. With zero weight, the maximum value you can have is 0.

We now have to break this problem down into subproblems.

Now we want to find the maximum value for a bag of maximum weight W and assessing all N objects. Since we have already assessed up to N-1 objects we only need to assess the Nth object. For the Nth object we can either take it or leave it. 

If we leave it, then it is the same as a bag of maximum weight W with N-1 objects because we are just ignoring the Nth object. 

[[[[{lang-html} max value leaving = maximum value of N-1 objects with weight W
]]]]

If we take it, then we need to find the maximum value thats possible while making room for that object and add that to the value of the object. 

[[[[{lang-html}max value taking = (maximum value of N-1 objects seen with weight W-weight of object N) + value of object N. 
]]]]

If we want the maximum value of assessing N objects and maximum weight W then we want the max of leaving the Nth object and taking the Nth object so:

[[[[{lang-html}
max value = max( maximum value taking, maximum value leaving)
max value = max( maximum value of N-1 objects with weight W, (maximum value of N-1 objects with weight W - weight of N) + value of N))
]]]]

Putting it all together we have:

[[[[{lang-html}
Let weight[i] be the weight of object i
Let value[i] be the value of object i

Let knapsack[i][j] be the maximum value that a knapsack of maximum weight j can hold with objects seen from 1 to i

Base case:
knapsack[0][0] = 0

Subproblem:
knapsack[i][j] = max(knapsack[i-1][j-weight[i]], knapsack[i-1][j-1])
]]]]

## [[Longest Common Subsequence]]

A subsequence is a subset of the original sequence that is in the same order. For example in the string "abcdefghi", "aeg" is a subsequence but "eaq" is not because it is not in order.

The longest common subsequence between two strings A and B is the longest subsequence in A that is also in B.

For example given A="xyaaaabcdeg", B="bcaaaaefgxy" the longest common subsequence is "aaaaeg"

[[[[{lang-html}
xyaaaabcde_g
bcaaaa___efgxy
]]]]

If we try to use greedy we will see it doesn't work. For example if we use try to take as much as B as we can, we see that we will get BCEG or if we try to take as much as A we get XY. 

Let first write a formal definition of the problem, given two strings A and B each with lengths N and M respectively we want to find the longest common subsequence between them.

**[Note to make reading easier I have used short forms for substring and index. For example A[3] means the 3rd character of A and A[1..4] means the substring of A from the first character to the fourth character inclusive. A[0] represents the null substring of A]**

The base is simple. The LCS of A[1..x] (where x is from 1 to N) and B[0] = 0. The LCS of B[1..x] and A[0] = 0.

We need to break this problem into subproblems. 

If A[N] = B[M] and then the new LCS is the LCS of A[1..N-1] and B[1..M-1]. Note that if two strings have the same character at the end of their string it has to be part of the LCS. Try to prove this to yourself.

[[[[{lang-html}
LCS of matched = (LCS of A from 1 to N-1, B from 1 to M-1) + A[N]
]]]]

If A[N] != B[M] then we try to match A[N] with B[M-1] or A[N-1] with B[M]. Thus we take the LCS of A[1..N-1] and B[1..M] and the LCS of A[1..N] and B[1..M-1].

[[[[{lang-html}
LCS of not matched = max ( (LCS of A[1..N], B[1..M-1]) , (LCS of A[1..N-1],B[1..M]))
]]]]

Putting it all together we have:
[[[[{lang-html}
Let LCS[i][j] be the length of longest common subsequence of A[1..i] and B[1..j] where 0< i ≤ n and 0 < j ≤ m.

Base case:
LCS[i][0] = 0 where 0< i ≤ n
LCS[0][j] = 0 where 0< j ≤ m

Subproblem:
if A[i] == B[j], LCS[i][j] = LCS[i-1][j-1]+1 where 0< i ≤ n and 0 < j ≤ m
if A[i] != B[j], LCS[i][j] = max( LCS[i-1][j], LCS[i][j-1] ) where 0< i ≤ n and 0 < j ≤ m
]]]]

## Exercises

1. Given an array of N integers, find the largest sum that can be using consecutive integers.
2. Given an array of N integers, find the longest increasing subsequence
3. Given a matrix of NxN integers, find the maximum sum of a submatrix