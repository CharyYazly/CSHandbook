## Introduction

Data structures are a way of storing data such that it can be accessed or changed in a efficient manner.

## [[Arrays]]

An array is the most basic data structure that holds a number of fixed elements of the same type in a block of data. The fact that it is in one block and the same type is important because it allows accessing the element at index i very quickly. 

However if you want to insert an element into an array at index i you will need to move everything past the ith element by 1 and similarly with deletion.

Arrays can be multidimensional meaning you can have an array of array of objects. 


### [[Vector]]

Vectors are arrays that are able to be dynamically resized. This allows the features of insertion, removal and deletion. Vectors are implemented as arrays and when more space is required, they are copied to a new array with twice the original size.


 Operation | Create | Get  | Set | Insert | Delete
-----------|---------|--
Time Complexity | O(1) | O(1)  | O(1) | O(n) | O(n)
### [[Linked List]] 

A **pointer** holds the memory location of another object.

A linked list is similar to an array but it is different such that it is not stored in one block of data. Each element can be stored in a random place in memory but each element contains a pointer to the next element thus forming a chain of pointers. Since the elements aren't in a block, accessing the ith element must be done by traversing the entire linked list by following each pointer to the next. However, this also allows insertion to be done more quickly by simply changing the point of the previous element and setting to the pointer of the current element to the next element. Deletion is also done by taking the previous element and changing its pointer to two elements ahead. 

A doubly linked list is a linked list that has pointers going backwards as well as forwards.


| Operation | Get | Add at node | Delete at node | Add | Delete
|-----------|---------|------------|---------
| Time Complexity | O(n) | O(n) | O(n) | O(1) | O(1)





### [[Queue]]

A queue is an array but with the property that it can only have removal from the front and insertion from the back (FIFI, first in first out). Removal from the front is called "pop" or "dequeue". Insertion from the back is called "push" or "enqueue". As the name implies queues are the same as those found in every day life, for example a queue for a bus stop. The first person in line for the bus will get on the bus first and the last person in line will get on the bus last.

Queues are often used for buffer systems, for example a text message service. The messages that arrive at the server first are relayed first and the messages that arrive later are relayed later.

Queues are usually implemented as a linked list because its memory size changes as more elements and pushed and popped.



| Operation | Pop | Push
|-
| Time Complexity | O(1) | O(1)



### [[Stack]]

A stack is an array with the property that it can only have removal and insertion from the back (FILO, first in last out). Remove from the back is called "pop" and insertion from the back is called "push". Imagine a stack of plates at a buffet, the plates are taken from the top and are also replaced from the top. 

Stacks are used for function calls on the memory stack. Whenever a function is called, it is placed on the memory stack with its variables and when it is returning a value, it is popped off the stack.



| Operation | Pop | Push
|-----------|-----|-----
| Time Complexity | O(1) | O(1)



## [[Sets]]

Sets are data structures that stores values and are used for testing if an element already exists within the set.  Sets generally have three operations: insertion, deletion and membership test. 

**Membership** test is checking whether an element exists within the set. Insertion places an element into the set and deletion removes an element from the set.


### [[Hash Sets]]

Hash sets are sets that use hashes to store elements. A hashing algorithm is an algorithm that takes an element and converts it to a smaller chunk called a **hash**. For example let our hashing algorithm be (x mod 10). So the hashes of 232, 217 and 10 be 2,7, and 9 respectively. 

For every element in a hash set, the hash is computed and elements with the same hash are grouped together and stored in a [[linked list|Linked List]]. The linked list is called a **bucket**.

If we want to check if an element already exists within the set, we first compute the hash of the element and then search through the linked list associated with the hash to see if the element is contained.

Let use the example of the hashset of the elements of 3242342, 3523, 123, 815 and 538. The hash set looks like this when computed:

Bucket | List
-------|-----
     1 |     
 2 | 3242342
 3 | 3523, 123
 4 |
 5 | 815
 6 |
 7 |
8 | 538
9 |

If we wanted to check if 7238 was in the hash set, we would get the hash (7238 mod 10 = 8). So we get the bucket associated with the hash 8 and we get the list of (538). When we iterate through this short list, we see that 7238 is not a member of the set. 

Similarly, if we wanted to insert 7238 into the hash set, we would check if it exists and if it did not we would append the element to the end of the bucket. For deletion we would find 7238 check if it existed in the set and remove it from the bucket. 

Hash sets are very efficient in all three set operations if a good hashing algorithm is used. When the objects are that being stored are large then hash sets are effective as a set.


| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(1) | O(1) | O(1)




###[[Tree Sets]]

A tree set is a set which stores the values in a [[binary tree|Binary Tree]]. To store elements in a tree set, they must be able to be sorted by a property. To insert an element, it is added to the binary tree. To delete an element, it is removed from the binary tree. To check for membership, we do a binary search for the element in the binary tree.

The advantage of tree sets is that they are maintained in a sorted order. 


| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(log n) | O(log n) | O(log n)


## [[Maps]]

Maps (also called dictionaries) are a data structure that store pairs of key-values and are used to retrieve values from the keys. For example an English dictionary is a map, the keys are the words and the values are the definitions. If you were to look up the word "map" you would use the key (the word "map" in the dictionary) to look up the value (definition of "map"). Maps use sets to store the keys which are paired with the values.


###[[Hash Map]]

Hash maps use [[hash sets|Hash Set]] to store the keys which then map to their values. The advantage of a hash map is that it is very fast but a disadvantage is that it is not sorted unlike a tree set.

| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(1) | O(1) | O(1)



### [[Tree Map]]

Tree maps use [[tree sets|Tree Set]] to store the keys which then maps to their values.

| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(log n) | O(log n) | O(log n)


## [[Trees]]

Trees are data structures that follow a hierarchy, each node has exactly one or zero parents and each node has children. Trees are recursive structures meaning that each child of a tree is also a tree. A tree within another tree is called a **subtree**.

A **child** is a node that is below another node. A **parent** is a node that is above another node.

The element at the top of the tree with no parents is called a **root**. The node at the bottom of the tree with no children is called a **leaf**. 

Each node can hold different kinds of information depending on the tree. A node can hold the children it has, the parent it has, a key associated with the node and a value associated with the node. 

### [[Binary Tree]]

A binary tree is a tree where each node has at most two children. 

A [[binary search tree|Binary Search Tree]] is a binary tree with special properties. Each node in a BST holds information about its children and a key. The BST has the property that all the nodes in the left subtree have keys smaller than the key of the parent node and all the nodes in the right subtree have keys greater than the key of the parent node. If we wanted to find if a key existed we could perform a search on the tree, if the key we are looking for is greater than the current node's key we go to the right subtree and if the key we are looking for is smaller, than we go to the left subtree.

### [[Segment Tree]]




## [[Heap]]

Heaps are trees which have the property that a node must either be greater than all the elements in its left and right subtrees (a max heap) or less than all the elements in its left and right subtrees (a min heap). [[Priority queue's|Priority Queue]] are most efficiently implemented as heaps.



| Operation       | Insert   | Remove   |
| --------------- | -------- | -------- |
| Time Complexity | O(log n) | O(log n) |


## [[Trie]]

A trie is tree which stores strings by their prefixes. A trie can replace a set for storing strings as it is faster than a hash set and it can the stored strings sorted but it takes more memory.

Let m be the length of the string.

| Operation | Membership | Insertion | Deletion 
|-
| Time Complexity | O(m) | O(m) | O(m)

