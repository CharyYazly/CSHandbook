## Introduction

Data structures are a way of storing data such that it can be accessed or changed in a efficient manner. Although many of these data structures are already implemented in various languages, it is important to understand how they work. By understanding the implementations we can have a sense of which data structure to use in different problems as well as determine their efficiencies.

For more intermediate data structures, read the the [[advanced data structures|Advanced Data Structures]] page.

## [[Arrays]]

Imagine you had a row of parking spaces where each was labelled with a number. If you wanted to know what the license plate of a car at parking space 4 was, all you have to do is go to the parking space and read off the license plate. If you wanted to park you car at parking space 5, you would go to parking space 5 and put your car in there if there was nothing there. Let's say that you had cars at parking spaces 1, 2, and 3. If you wanted to insert a new car at parking space 1 and keep the rest of the cars in the same order, you would have to shift the cars in the parking spaces from 1, 2 and 3 to 2, 3 and 4 by getting in each car and parking them in the new spaces which would take some time. This type of structure is an array.

An **array** is the most basic data structure that stores elements of the same type in a fixed block. The fact that it is in one block and the same type is important because it allows accessing elements very quickly if you have the index. All you have to do is go to the index and retrieve the element. However, inserting elements in the array is slow because you would have to shift all the elements and also if you want to shift past the fixed size you will get an error. (Imagine the parking spaces are full and you wanted to insert a car somewhere, there will still be one car that will have no parking space).

Arrays can be multidimensional meaning you can have an array of array of objects. (Imagine a parking lot with multiple rows of parking spaces).

| Operation | Create | Get | Set
|-----------|-----|-----
| Time Complexity | O(n) | O(1) | O(1)

## [[Vector]]

Imagine you had a ???

A **vector** is an array that can be dynamically resized. This allows the features of insertion, removal and deletion. Vectors are implemented as arrays and when more space is required, they are copied to a new array with twice the original size.


 Operation | Create | Get  | Set | Insert | Delete
-----------|---------|--
Time Complexity | O(n) | O(1)  | O(1) | O(n) | O(n)

## [[Linked List]] 

Imagine you had some train cars that were linked together where each was labelled on the inside with a different letter. If you had to find a specific letter you would have to start at the first train car and look inside to check the letter and then walk into the next train car to check the letter and so forth until you found the train car you wanted. If you wanted to insert a train car somewhere all you would have to do it unlink the position where you wanted to insert it and then relink the new train car with the other cars. If you wanted to remove a train car all you would have to do is unlink that car from the other cars and then create a new link to the cars that were adjacent to it. This sort of structure is called a linked list.

A **pointer** is something that holds the memory location of another object.

A **linked list** is similar to an array but it is different such that it is not stored in one block of data. Each element can be stored in a random place in memory but each element contains a pointer to the next element thus forming a chain of pointers. Think of a pointer as a link that links two train cars. Since the elements aren't in a block, accessing an element must be done by traversing the entire linked list by following each pointer to the next. However, this also allows insertion to be done more quickly by simply changing the point of the previous element and setting to the pointer of the current element to the next element. Deletion is also done by taking the previous element and changing its pointer to two elements ahead. In a linked list the links only go forward and you cannot move backward. 

A **doubly linked list** is a linked list that has pointers going backwards as well as forwards.


| Operation | Get | Add at node | Delete at node | Add | Delete
|-----------|---------|------------|---------
| Time Complexity | O(n) | O(1) | O(1) | O(n) | O(n)


## [[Queue]]

Imagine you are standing in line for a restaurant. Whoever is first in line will be served and whoever is last in line will be served last. People can be served while more people join the line and the line may get very long because the time it takes to serve one person is long while more people join the queue. This line is also called a queue.

A queue is a structure with the property that it can only have removal from the front and insertion from the back (FIFI, first in first out). Removal from the front is called "pop" or "dequeue". Insertion from the back is called "push" or "enqueue".

Queues are usually implemented as a linked list because its memory size changes as more elements and pushed or popped and insertion from the front is more efficient.

Queues are often used for buffer systems, for example a text message service. The messages that arrive at the server first are relayed first and the messages that arrive later are relayed later. If there are too many text messages in the system such that the rate  texts are received overwhelm the number of texts that are sent the buffer may overflow and messages will get dropped. Most of the time this won't happen because the systems are designed to handle large loads, but if there were an emergency that caused everyone to start texting many texts could be dropped.


| Operation | Pop | Push
|-
| Time Complexity | O(1) | O(1)

## [[Stack]]

Imagine a stack of plates at a buffet, the plates are taken from the top and are also replaced from the top. The first plate to go in will be the last plate to come out. The last plate to go in will be the first to come out. This structure is called a stack.

A stack is an array with the property that it can only have removal and insertion from the back (FILO, first in last out). Remove from the back is called "pop" and insertion from the back is called "push". 

Stacks are used for function calls on the memory stack. Whenever a function is called, it is placed on the memory stack with its variables and when it is returning a value, it is popped off the stack.

| Operation | Pop | Push
|-----------|-----|-----
| Time Complexity | O(1) | O(1)

## [[Sets]]

Imagine you have a grocery list that you use to keep tracking of things you need to buy. You want to make sure there are no duplicate items in the list, you can add items to the list and that you can remove items from your list. This structure is similar to what a set does.

Sets are data structures that stores values and are used for three operations: insertion, deletion and membership test. 

Insertion places an element into the set, deletion removes an element from the set and a **membership** test is checking whether an element exists within the set.


### [[Hash Sets]]

Hash sets are sets that use hashes to store elements. A hashing algorithm is an algorithm that takes an element and converts it to a smaller chunk called a **hash**. For example let our hashing algorithm be (x mod 10). So the hashes of 232, 217 and 10 be 2,7, and 9 respectively. 

For every element in a hash set, the hash is computed and elements with the same hash are grouped together and stored in a [[linked list|Linked List]]. The linked list is called a **bucket**.

If we want to check if an element already exists within the set, we first compute the hash of the element and then search through the linked list associated with the hash to see if the element is contained.

Let use the example of the hashset of the elements of 3242342, 3523, 123, 815 and 538. The hash set looks like this when computed:

Bucket | List
-------|-----
     1 |     
 2 | 3242342
 3 | 3523, 123
 4 |
 5 | 815
 6 |
 7 |
8 | 538
9 |

If we wanted to check if 7238 was in the hash set, we would get the hash (7238 mod 10 = 8). So we get the bucket associated with the hash 8 and we get the list of (538). When we iterate through this short list, we see that 7238 is not a member of the set. 

Similarly, if we wanted to insert 7238 into the hash set, we would check if it exists and if it did not we would append the element to the end of the bucket. For deletion we would find 7238 check if it existed in the set and remove it from the bucket. 

Hash sets are very efficient in all three set operations if a good hashing algorithm is used. When the objects are that being stored are large then hash sets are effective as a set.


| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(1) | O(1) | O(1)

### [[Tree Sets]]
A tree set is a set which stores the values in a [[binary tree|Binary Tree]]. To store elements in a tree set, they must be able to be sorted by a property. To insert an element, it is added to the binary tree. To delete an element, it is removed from the binary tree. To check for membership, we do a binary search for the element in the binary tree.

The advantage of tree sets is that they are maintained in a sorted order. 


| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(log n) | O(log n) | O(log n)


## [[Maps]]

Maps (also called dictionaries) are a data structure that store pairs of key-values and are used to retrieve values from the keys. For example an English dictionary is a map, the keys are the words and the values are the definitions. If you were to look up the word "map" you would use the key (the word "map" in the dictionary) to look up the value (definition of "map"). Maps use sets to store the keys which are paired with the values.


###[[Hash Map]]

Hash maps use [[hash sets|Hash Set]] to store the keys which then map to their values. The advantage of a hash map is that it is very fast but a disadvantage is that it is not sorted unlike a tree set.

| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(1) | O(1) | O(1)



### [[Tree Map]]

Tree maps use [[tree sets|Tree Set]] to store the keys which then maps to their values.

| Operation | Membership | Insertion | Deletion
|-
| Time Complexity | O(log n) | O(log n) | O(log n)


## [[Trees]]

Trees are data structures that follow a hierarchy, each node has exactly one or zero parents and each node has children. Trees are recursive structures meaning that each child of a tree is also a tree. A tree within another tree is called a **subtree**.

A **child** is a node that is below another node. A **parent** is a node that is above another node.

The element at the top of the tree with no parents is called a **root**. The node at the bottom of the tree with no children is called a **leaf**. 

Each node can hold different kinds of information depending on the tree. A node can hold the children it has, the parent it has, a key associated with the node and a value associated with the node. 

### [[Binary Tree]]

A binary tree is a tree where each node has at most two children. 

A [[binary search tree|Binary Search Tree]] is a binary tree with special properties. Each node in a BST holds information about its children and a key. The BST has the property that all the nodes in the left subtree have keys smaller than the key of the parent node and all the nodes in the right subtree have keys greater than the key of the parent node. If we wanted to find if a key existed we could perform a search on the tree, if the key we are looking for is greater than the current node's key we go to the right subtree and if the key we are looking for is smaller, than we go to the left subtree.


## [[Heap]]

Heaps are trees which have the property that a node must either be greater than all the elements in its left and right subtrees (a max heap) or less than all the elements in its left and right subtrees (a min heap). [[Priority queue's|Priority Queue]] are most efficiently implemented as heaps.



| Operation       | Insert   | Remove   |
| --------------- | -------- | -------- |
| Time Complexity | O(log n) | O(log n) |



